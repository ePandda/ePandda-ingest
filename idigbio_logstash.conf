input {
	stdin {
		"type" => "csv"
	}
}
filter {
	csv {
		columns => ["coreid", "idigbio:associatedsequences", "idigbio:barcodeValue", "dwc:basisOfRecord", "dwc:bed", "gbif:canonicalName", "dwc:catalogNumber", "dwc:class", "dwc:collectionCode", "dwc:collectionID", "idigbio:collectionName", "dwc:recordedBy", "dwc:vernacularName", "idigbio:commonnames", "dwc:continent", "dwc:coordinateUncertaintyInMeters", "dwc:country", "idigbio:isoCountryCode", "dwc:county", "idigbio:eventDate", "idigbio:dateModified", "idigbio:dataQualityScore", "dwc:earliestAgeOrLowestStage", "dwc:earliestEonOrLowestEonothem", "dwc:earliestEpochOrLowestSeries", "dwc:earliestEraOrLowestErathem", "dwc:earliestPeriodOrLowestSystem", "idigbio:etag", "dwc:oldEventDate", "dwc:family", "dwc:fieldNumber", "idigbio:flags", "dwc:formation", "dwc:genus", "dwc:geologicalContextID", "idigbio:geoPoint", "dwc:group", "idigbio:hasImage", "idigbio:hasMedia", "dwc:higherClassification", "dwc:highestBiostratigraphicZone", "dwc:individualCount", "dwc:infraspecificEpithet", "dwc:institutionCode", "dwc:institutionID", "idigbio:institutionName", "dwc:kingdom", "dwc:latestAgeOrHighestStage", "dwc:latestEonOrHighestEonothem", "dwc:latestEpochOrHighestSeries", "dwc:latestEraOrHighestErathem", "dwc:latestPeriodOrHighestSystem", "dwc:lithostratigraphicTerms", "dwc:locality", "dwc:lowestBiostratigraphicZone", "dwc:maximumDepthInMeters", "dwc:maximumElevationInMeters", "idigbio:mediarecords", "dwc:member", "dwc:minimumDepthInMeters", "dwc:minimumElevationInMeters", "dwc:municipality", "dwc:occurrenceID", "dwc:order", "dwc:phylum", "idigbio:recordIds", "dwc:recordNumber", "idigbio:recordset", "dwc:scientificName", "dwc:specificEpithet", "dwc:startDayOfYear", "dwc:stateProvince", "dwc:taxonID", "dwc:taxonomicStatus", "dwc:taxonRank", "dwc:typeStatus", "idigbio:uuid", "dwc:verbatimEventDate", "dwc:verbatimLocality", "idigbio:version", "dwc:waterBody", "dwc:eventDateEarly", "dwc:eventDateLate"]
		remove_field => ["dwc:eventDate", "dwc:oldEventDate"]
	}
	json{
		source => "idigbio:flags"
		target => "idigbio:flags"
		skip_on_invalid_json => true
	}
	json{
		source => "idigbio:recordIds"
		target => "idigbio:recordIds"
		skip_on_invalid_json => true
	}
}
output {
	elasticsearch {
		id => "idb_ingest"
		hosts => "localhost:9200"
		index => "idigbio2"
		document_type => "idigbio"
		document_id => "%{idigbio:uuid}"
		doc_as_upsert => true
		sniffing => false
	}
}
